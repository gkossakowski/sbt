/* sbt -- Simple Build Tool
 * Copyright 2010  Mark Harrah
 */
package sbt
package inc

import xsbti.api.Source
import java.io.File
import Relations.SourceDependencies
import Relations.SourceDependenciesByClassName


/** Provides mappings between source files, generated classes (products), and binaries.
* Dependencies that are tracked include internal: a dependency on a source in the same compilation group (project),
* external: a dependency on a source in another compilation group (tracked as the name of the class),
* binary: a dependency on a class or jar file not generated by a source file in any tracked compilation group,
* inherited: a dependency that resulted from a public template inheriting,
* direct: any type of dependency, including inheritance. */
trait Relations
{
	/** All sources _with at least one product_ . */
	def allSources: collection.Set[File]

	/** All products associates with sources. */
	def allProducts: collection.Set[File]

	/** All files that are recorded as a binary dependency of a source file.*/
	def allBinaryDeps: collection.Set[File]

	/** All files in this compilation group (project) that are recorded as a source dependency of a source file in this group.*/
	def allInternalSrcDeps: collection.Set[String]

	/** All files in another compilation group (project) that are recorded as a source dependency of a source file in this group.*/
	def allExternalDeps: collection.Set[String]

	/** Fully qualified names of classes defined in source file `src`. */
	def classNames(src: File): Set[String]

	/** Names of classes defined in source file `src`. */
	def definesClass(name: String): Set[File]

	/**
	 * Names (fully qualified, at pickler phase) of classes defined in source
	 * file `src`.
	 */
	def declaredClassNames(src: File): Set[String]

	/** The classes that were generated for source file `src`. */
	def products(src: File): Set[File]
	/** The source files that generated class file `prod`.  This is typically a set containing a single file. */
	def produced(prod: File): Set[File]

	/** The binary dependencies for the source file `src`. */
	def binaryDeps(src: File): Set[File]
	/** The source files that depend on binary file `dep`. */
	def usesBinary(dep: File): Set[File]

	/** Internal source dependencies for `src`.  This includes both direct and inherited dependencies.  */
	def internalSrcDeps(src: File): Set[File] = internalClassNameDeps(src).flatMap(definesClass)
	/** Internal source files that depend on internal source `dep`.  This includes both direct and inherited dependencies.  */
	def usesInternalSrc(dep: File): Set[File] = classNames(dep).flatMap(usesInternalClassName)

	/** Internal source dependencies for `src`.  This includes both direct and inherited dependencies.  */
	def internalClassNameDeps(src: File): Set[String]
	/** Internal source files that depend on internal source `dep`.  This includes both direct and inherited dependencies.  */
	def usesInternalClassName(className: String): Set[File]

	/** External source dependencies that internal source file `src` depends on.  This includes both direct and inherited dependencies.  */
	def externalDeps(src: File): Set[String]
	/** Internal source dependencies that depend on external source file `dep`.  This includes both direct and inherited dependencies.  */
	def usesExternal(dep: String): Set[File]

	def usedNames(src: File): Set[String]

	/** Records internal source file `src` as generating class file `prod` with top-level class `name`. */
	def addProduct(src: File, prod: File, name: String): Relations

	/** Records internal source file `src` as depending on class `dependsOn` in an external source file.
	* If `inherited` is true, this dependency is recorded as coming from a public template in `src` extending something in `dependsOn` (an inheritance dependency).
	* Whatever the value of `inherited`, the dependency is also recorded as a direct dependency. */
	def addExternalDep(src: File, dependsOn: String, inherited: Boolean): Relations

	/** Records internal source file `src` depending on a dependency binary dependency `dependsOn`.*/
	def addBinaryDep(src: File, dependsOn: File): Relations


	/** Records internal source file `src` as having direct dependencies on internal source files `directDependsOn`
	* and inheritance dependencies on `inheritedDependsOn`.  Everything in `inheritedDependsOn` must be included in `directDependsOn`;
	* this method does not automatically record direct dependencies like `addExternalDep` does.*/
	def addInternalSrcDeps(src: File, directDependsOn: Iterable[File], inheritedDependsOn: Iterable[File]): Relations

	/** Records internal source file `src` as having direct dependencies on internal class names `directDependsOn`
	* and inheritance dependencies on `inheritedDependsOn`.  Everything in `inheritedDependsOn` must be included in `directDependsOn`;
	* this method does not automatically record direct dependencies like `addExternalDep` does.*/
	def addInternalClassNameDeps(src: File, directDependsOn: Iterable[String], inheritedDependsOn: Iterable[String]): Relations

	def addUsedName(src: File, name: String): Relations

	def addDeclaredClass(src: File, className: String): Relations

	def ++ (o: Relations): Relations

	/** Drops all dependency mappings from `sources`.  This will not remove mappings to them (that is, mappings where they are dependencies).*/
	def -- (sources: Iterable[File]): Relations

	def groupBy[K](f: (File => K)): Map[K, Relations]

	/** The relation between internal sources and generated class files. */
	def srcProd: Relation[File, File]

	/** The dependency relation between internal sources and binaries. */
	def binaryDep: Relation[File, File]

	/** The dependency relation between internal sources.  This includes both direct and inherited dependencies.*/
	def internalSrcDep: Relation[File, String]

	/** The dependency relation between internal and external sources.  This includes both direct and inherited dependencies.*/
	def externalDep: Relation[File, String]

	/**
	 * The source dependency relation between source files introduced by member reference.
	 *
	 * NOTE: All inheritance dependencies are included in this relation because in order to
	 * inherit from a member you have to refer to it.
	 */
	def memberRef: SourceDependenciesByClassName

	/**
	 * The source dependency relation between source files introduced by inheritance.
	 * The dependency by inheritance is introduced when a template (class or trait) mentions
	 * a given type in a parent position.
	 *
	 * NOTE: Due to an oddity in how Scala's type checker works there's one unexpected dependency
	 * on a class being introduced. An example illustrates the best the problem. Let's consider
	 * the following structure:
	 *
	 * trait A extends B
	 * trait B extends C
	 * trait C extends D
	 * class D
	 *
	 * We are interested in dependencies by inheritance of `A`. One would expect it to be just `B`
	 * but the answer is `B` and `D`. The reason is because Scala's type checker performs a certain
	 * normalization so the first parent of a type is a class. Therefore the example above is normalized
	 * to the following form:
	 *
	 * trait A extends D with B
	 * trait B extends D with C
	 * trait C extends D
	 * class D
	 *
	 * Therefore if you inherit from a trait you'll get an additional dependency on a class that is
	 * resolved transitively.
	 *
	 */
	def inheritance: SourceDependenciesByClassName

	/** The dependency relations between sources.  These include both direct and inherited dependencies.*/
	@deprecated("Use `memberRef` instead. Note that `memberRef` doesn't include transitive inheritance dependencies.")
	def direct: SourceDependencies
	/** The inheritance dependency relations between sources.*/
	@deprecated("Use `inheritance` instead. Note that `inheritance` doesn't include transitive inheritance dependencies.")
	def publicInherited: SourceDependencies

	/** The relation between a source file and names of classes generated from it.*/
	def classes: Relation[File, String]
	/**
	 * The relation between a source file and names of classes declared in it.
	 *
	 * Names of classes are fully qualified names as seen at pickler phase (i.e. before flattening).
	 * Objects are represented as object name with dollar sign appended to it.
	 */
	def declaredClasses: Relation[File, String]
	/**
	 * Relation between source files and _unqualified_ term and type names used in given source file.
	 */
	def names: Relation[File, String]
}


object Relations
{
	/** Tracks internal and external source dependencies for a specific dependency type, such as direct or inherited.*/
	final class SourceDependencies private[sbt](val internal: Relation[File,File], val external: Relation[File,String]) {
		def addInternal(source: File, dependsOn: Iterable[File]): SourceDependencies = new SourceDependencies(internal + (source, dependsOn), external)
		def addExternal(source: File, dependsOn: String): SourceDependencies = new SourceDependencies(internal, external + (source, dependsOn))
		/** Drops all dependency mappings from `sources`.  This will not remove mappings to them (that is, where they are dependencies).*/
		def --(sources: Iterable[File]): SourceDependencies = new SourceDependencies(internal -- sources, external -- sources)
		def ++(o: SourceDependencies): SourceDependencies = new SourceDependencies(internal ++ o.internal, external ++ o.external)
		def groupBySource[K](f: File => K): Map[K, SourceDependencies] = {
			val i = internal.groupBy { case (a,b) => f(a) }
			val e = external.groupBy { case (a,b) => f(a) }
			val pairs = for( k <- i.keySet ++ e.keySet ) yield
				(k, new SourceDependencies( getOrEmpty(i, k), getOrEmpty(e, k) ))
			pairs.toMap
		}
	}

	final class SourceDependenciesByClassName private[sbt](val internal: Relation[File,String], val external: Relation[File,String]) {
		def addInternal(source: File, dependsOn: Iterable[String]): SourceDependenciesByClassName =
			new SourceDependenciesByClassName(internal + (source, dependsOn), external)
		def addExternal(source: File, dependsOn: String): SourceDependenciesByClassName = new SourceDependenciesByClassName(internal, external + (source, dependsOn))
		/** Drops all dependency mappings from `sources`.  This will not remove mappings to them (that is, where they are dependencies).*/
		def --(sources: Iterable[File]): SourceDependenciesByClassName = new SourceDependenciesByClassName(internal -- sources, external -- sources)
		def ++(o: SourceDependenciesByClassName): SourceDependenciesByClassName = new SourceDependenciesByClassName(internal ++ o.internal, external ++ o.external)
		def groupBySource[K](f: File => K): Map[K, SourceDependenciesByClassName] = {
			val i = internal.groupBy { case (a,b) => f(a) }
			val e = external.groupBy { case (a,b) => f(a) }
			val pairs = for( k <- i.keySet ++ e.keySet ) yield
				(k, new SourceDependenciesByClassName( getOrEmpty(i, k), getOrEmpty(e, k) ))
			pairs.toMap
		}
	}

	private[sbt] def getOrEmpty[A,B,K](m: Map[K, Relation[A,B]], k: K): Relation[A,B] = m.getOrElse(k, Relation.empty)

	private[this] lazy val e = Relation.empty[File, File]
	private[this] lazy val estr = Relation.empty[File, String]
	private[this] lazy val es = new SourceDependencies(e, estr)
	private[this] lazy val esbcn = new SourceDependenciesByClassName(estr, estr)

	def emptySourceDependencies: SourceDependencies = es
	def emptySourceDependenciesByClassName: SourceDependenciesByClassName = esbcn
	def empty: Relations = new MRelations(e, e, es, es, esbcn, esbcn, estr, estr, estr)

	def make(srcProd: Relation[File, File], binaryDep: Relation[File, File],
			direct: SourceDependencies, publicInherited: SourceDependencies,
			memberRef: SourceDependenciesByClassName,
			inheritance: SourceDependenciesByClassName, classes: Relation[File, String],
			names: Relation[File, String], declaredClasses: Relation[File, String]): Relations =
		new MRelations(srcProd, binaryDep, direct, publicInherited, memberRef, inheritance, classes,
				names, declaredClasses)
	def makeSourceDependencies(internal: Relation[File,File], external: Relation[File,String]): SourceDependencies = new SourceDependencies(internal, external)
	def makeSourceDependenciesByClassName(internal: Relation[File,String], external: Relation[File,String]): SourceDependenciesByClassName =
		new SourceDependenciesByClassName(internal, external)
}
/**
* `srcProd` is a relation between a source file and a product: (source, product).
* Note that some source files may not have a product and will not be included in this relation.
*
* `binaryDeps` is a relation between a source file and a binary dependency: (source, binary dependency).
*   This only includes dependencies on classes and jars that do not have a corresponding source/API to track instead.
*   A class or jar with a corresponding source should only be tracked in one of the source dependency relations.
*
* `direct` defines relations for dependencies between internal and external source dependencies.  It includes all types of
*   dependencies, including inheritance.
*
* `publicInherited` defines relations for internal and external source dependencies, only including dependencies
*   introduced by inheritance.
*
* `classes` is a relation between a source file and its generated class names.
*/
private class MRelations(val srcProd: Relation[File, File], val binaryDep: Relation[File, File],
    // direct should include everything in inherited
    val direct: SourceDependencies, val publicInherited: SourceDependencies,
	// member ref should include everything in inheritance
	val memberRef: SourceDependenciesByClassName, val inheritance: SourceDependenciesByClassName,
	val classes: Relation[File, String], val names: Relation[File, String],
	val declaredClasses: Relation[File, String]) extends Relations
{
	def internalSrcDep: Relation[File, String] = memberRef.internal
	def externalDep: Relation[File, String] = memberRef.external

	def allSources: collection.Set[File] = srcProd._1s

	def allProducts: collection.Set[File] = srcProd._2s
	def allBinaryDeps: collection.Set[File] = binaryDep._2s
	def allInternalSrcDeps: collection.Set[String] = memberRef.internal._2s
	def allExternalDeps: collection.Set[String] = memberRef.external._2s

	def classNames(src: File): Set[String] = classes.forward(src)
	def definesClass(name: String): Set[File] = classes.reverse(name)

	def declaredClassNames(src: File): Set[String] = declaredClasses.forward(src)

	def products(src: File): Set[File] = srcProd.forward(src)
	def produced(prod: File): Set[File] = srcProd.reverse(prod)

	def binaryDeps(src: File): Set[File] = binaryDep.forward(src)
	def usesBinary(dep: File): Set[File] = binaryDep.reverse(dep)

	def internalClassNameDeps(src: File): Set[String] = memberRef.internal.forward(src)
	def usesInternalClassName(className: String): Set[File] = memberRef.internal.reverse(className)

	def externalDeps(src: File): Set[String] = memberRef.external.forward(src)
	def usesExternal(dep: String): Set[File] = memberRef.external.reverse(dep)

	def usedNames(src: File): Set[String] = names.forward(src)

	def addProduct(src: File, prod: File, name: String): Relations =
		new MRelations( srcProd + (src, prod), binaryDep, direct = direct, publicInherited = publicInherited,
				memberRef = memberRef, inheritance = inheritance,
				classes + (src, name), names, declaredClasses)

	def addExternalDep(src: File, dependsOn: String, inherited: Boolean): Relations = {
		val newDirect = direct.addExternal(src, dependsOn)
		val newPublicInherited = if(inherited) publicInherited.addExternal(src, dependsOn) else publicInherited
		val newMemberRef = memberRef.addExternal(src, dependsOn)
		val newInheritance = if(inherited) inheritance.addExternal(src, dependsOn) else inheritance
		new MRelations( srcProd, binaryDep, newDirect, newPublicInherited, newMemberRef, newInheritance, classes,
				names, declaredClasses)
	}

	def addInternalSrcDeps(src: File, dependsOn: Iterable[File], inherited: Iterable[File]): Relations = {
		val newI = publicInherited.addInternal(src, inherited)
		val newD = direct.addInternal(src, dependsOn)
		new MRelations( srcProd, binaryDep, direct = newD, publicInherited = newI, memberRef, inheritance, classes,
				names, declaredClasses)
	}

	def addInternalClassNameDeps(src: File, dependsOn: Iterable[String], inherited: Iterable[String]): Relations = {
		val newI = inheritance.addInternal(src, inherited)
		val newD = memberRef.addInternal(src, dependsOn)
		new MRelations( srcProd, binaryDep, direct, publicInherited, memberRef = newD, inheritance = newI, classes,
				names, declaredClasses)
	}

	def addUsedName(src: File, name: String): Relations =
		new MRelations( srcProd, binaryDep, direct, publicInherited, memberRef, inheritance, classes,
				names + (src, name), declaredClasses)

	def addDeclaredClass(src: File, className: String): Relations =
		new MRelations( srcProd, binaryDep, direct, publicInherited, memberRef, inheritance, classes,
				names, declaredClasses + (src, className))

	def addBinaryDep(src: File, dependsOn: File): Relations =
		new MRelations( srcProd, binaryDep + (src, dependsOn), direct, publicInherited,
				memberRef = memberRef, inheritance = inheritance, classes, names, declaredClasses)

	def ++ (o: Relations): Relations =
		new MRelations(srcProd ++ o.srcProd, binaryDep ++ o.binaryDep, direct ++ o.direct,
				publicInherited ++ o.publicInherited, memberRef = memberRef ++ o.memberRef,
				inheritance = inheritance ++ o.inheritance, classes ++ o.classes, names ++ o.names,
				declaredClasses ++ o.declaredClasses)
	def -- (sources: Iterable[File]) =
		new MRelations(srcProd -- sources, binaryDep -- sources, direct -- sources, publicInherited -- sources,
				memberRef = memberRef -- sources,
				inheritance = inheritance -- sources, classes -- sources, names -- sources,
				declaredClasses -- sources)

	def groupBy[K](f: File => K): Map[K, Relations] =
	{
		type MapRel[T] = Map[K, Relation[File, T]]
		def outerJoin(srcProdMap: MapRel[File], binaryDepMap: MapRel[File],
				direct: Map[K, SourceDependencies], publicInherited: Map[K, SourceDependencies],
				memberRef: Map[K, SourceDependenciesByClassName],
				inherited: Map[K, SourceDependenciesByClassName],
			classesMap: MapRel[String],  namesMap: MapRel[String],
			declaredClassesMap: MapRel[String]): Map[K, Relations] =
		{
			def kRelations(k: K): Relations = {
				def get[T](m: Map[K, Relation[File, T]]) = Relations.getOrEmpty(m, k)
				def getSrc(m: Map[K, SourceDependencies]): SourceDependencies =
					m.getOrElse(k, Relations.emptySourceDependencies)
				def getDependenciesByClassName(m: Map[K, SourceDependenciesByClassName]): SourceDependenciesByClassName =
					m.getOrElse(k, Relations.emptySourceDependenciesByClassName)
				new MRelations( get(srcProdMap), get(binaryDepMap), getSrc(direct), getSrc(publicInherited),
						getDependenciesByClassName(memberRef), getDependenciesByClassName(inherited),
						get(classesMap), get(namesMap), get(declaredClassesMap) )
			}
			val keys = (srcProdMap.keySet ++ binaryDepMap.keySet ++ direct.keySet ++ inherited.keySet ++ classesMap.keySet).toList
			Map( keys.map( (k: K) => (k, kRelations(k)) ) : _*)
		}

		def f1[B](item: (File, B)): K = f(item._1)
		outerJoin(srcProd.groupBy(f1), binaryDep.groupBy(f1), direct.groupBySource(f), publicInherited.groupBySource(f),
				memberRef.groupBySource(f), inheritance.groupBySource(f),
				classes.groupBy(f1), names.groupBy(f1), declaredClasses.groupBy(f1))
    }


  /** Making large Relations a little readable. */
  private val userDir = sys.props("user.dir").stripSuffix("/") + "/"
  private def nocwd(s: String)              = s stripPrefix userDir
  private def line_s(kv: (Any, Any))        = "    " + nocwd("" + kv._1) + " -> " + nocwd("" + kv._2) + "\n"
  private def relation_s(r: Relation[_, _]) = (
    if (r.forwardMap.isEmpty) "Relation [ ]"
    else (r.all.toSeq map line_s sorted) mkString ("Relation [\n", "", "]")
  )
	override def toString = (
	  """
	  |Relations:
	  |  products: %s
	  |  bin deps: %s
	  |  src deps: %s
	  |  ext deps: %s
	  |  class names: %s
	  |  declared classes: %s,
	  """.trim.stripMargin.format(List(srcProd, binaryDep, internalSrcDep, externalDep, classes, declaredClasses) map relation_s : _*)
	)
}
